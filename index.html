# Create a full project bundle (frontend + contract + metadata + README) and zip it for user download.
import os, zipfile, shutil, json, textwrap

project_dir = "/mnt/data/vision-glasses-complete"
if os.path.exists(project_dir):
    shutil.rmtree(project_dir)
os.makedirs(project_dir, exist_ok=True)

# index.html with both Telegram + WalletConnect + ethers + contract option
index_html = """<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vision Glasses — Mint (ETH)</title>
<link rel="icon" href="data:,"/>
<style>
  :root{--bg:#071026;--card:#0f1724;--accent:#00e6e6;--muted:#9fb4d6;--success:#16a34a}
  body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071026 0%, #04060a 100%);color:#e6f0ff;display:flex;align-items:center;justify-content:center;min-height:100vh;padding:28px;}
  .card{width:100%;max-width:900px;background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));border-radius:14px;padding:22px;border:1px solid rgba(255,255,255,.04);box-shadow:0 18px 50px rgba(2,6,23,.65)}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  h1{margin:0;font-size:20px;color:var(--accent)}
  .sub{color:var(--muted);font-size:13px}
  .grid{display:grid;grid-template-columns:320px 1fr;gap:18px;margin-top:18px}
  .nft-preview{background:linear-gradient(180deg, rgba(255,255,255,.01), rgba(255,255,255,.00));padding:12px;border-radius:10px;border:1px dashed rgba(255,255,255,.04);display:flex;flex-direction:column;align-items:center;gap:10px}
  .nft-preview img{max-width:100%;border-radius:8px;box-shadow:0 10px 30px rgba(2,10,20,.6)}
  .meta{font-size:16px;color:#e6f0ff}
  .price{font-weight:700;color:var(--accent);margin-top:6px}
  .controls{display:flex;flex-direction:column;gap:12px}
  .btn{padding:12px 14px;border-radius:10px;border:0;font-weight:700;cursor:pointer}
  .btn.connect{background:#2b3a55;color:#fff}
  .btn.mint{background:linear-gradient(90deg,#00c2b3,#00e6e6);color:#001219}
  .row{display:flex;gap:10px;align-items:center}
  .small{font-size:13px;color:var(--muted)}
  .walletBox{padding:12px;border-radius:10px;background:#091022;border:1px solid rgba(255,255,255,.03)}
  .success{color:var(--success);font-weight:700}
  .footer{margin-top:14px;font-size:13px;color:var(--muted)}
  @media (max-width:820px){ .grid{grid-template-columns:1fr;} }
</style>
</head>
<body>
  <div class="card" role="main">
    <header>
      <div>
        <h1>Vision Glasses</h1>
        <div class="sub">Limited Edition • LuminaVerse — ETH collection</div>
      </div>
      <div style="text-align:right">
        <div id="tgUser" class="small">Not opened in Telegram</div>
        <div id="walletShort" class="small" style="margin-top:6px">Wallet: —</div>
      </div>
    </header>

    <div class="grid" style="align-items:start">
      <div class="nft-preview">
        <img id="nftImage" src="glasses.png" alt="Vision Glasses NFT preview" />
        <div class="meta">Vision Glasses — Limited Drop</div>
        <div class="price">$50 (pay in ETH)</div>
        <div class="small">Payment address / contract:</div>
        <div class="walletBox" id="receiverBox">0xc15a5316B75ab200E0c24688f85ef9612D70bBd8</div>
      </div>

      <div class="controls">
        <div class="walletBox">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <div class="small">Connected wallet</div>
              <div id="connectedAddr" style="font-weight:700">—</div>
            </div>
            <div>
              <button class="btn connect" id="btnConnect">Connect Wallet</button>
            </div>
          </div>

          <div style="margin-top:10px" id="networkInfo" class="small">Network: —</div>
          <div style="margin-top:8px" class="small">
            <label><input type="checkbox" id="useContract" /> Use contract mint (if configured)</label>
          </div>
        </div>

        <div style="display:flex;gap:10px;align-items:center">
          <button class="btn mint" id="btnMint">Mint / Pay $50</button>
          <div id="mintStatus" class="small">Status: waiting</div>
        </div>

        <div class="small">Notes: If you provide a deployed contract address and ABI in <code>config.json</code>, the page will call <code>mintNFT(tokenURI)</code>. Otherwise it sends ETH directly to the receiver address.</div>

        <div class="footer">
          Future: add BTC & BNB collections — they will appear here. Opened inside Telegram? the app will show your Telegram name.
        </div>
      </div>
    </div>
  </div>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.7.8/dist/umd/index.min.js"></script>

  <script>
  (async function(){
    // ---- CONFIG (edit config.json instead of code) ----
    // RECEIVER_ADDRESS is used when no contract is provided.
    const RECEIVER_ADDRESS = "0xc15a5316B75ab200E0c24688f85ef9612D70bBd8";
    const ETH_AMOUNT = "0.03"; // ~ $50 (adjust as needed)
    // If you deploy the VisionGlassesNFT contract, set CONTRACT_ADDRESS and TOKEN_URI in config.json
    // CONTRACT_ABI will be read from config.json if present.
    // --------------------------------------------------

    // Try to load config.json (optional)
    let config = {};
    try {
      const res = await fetch('config.json');
      if (res.ok) config = await res.json();
    } catch(e){ /* no config */ }

    // Merge config values (if provided)
    const CONTRACT_ADDRESS = config.contractAddress || null;
    const CONTRACT_ABI = config.contractAbi || null;
    const TOKEN_URI = config.tokenURI || null; // e.g., ipfs://Qm...

    // DOM elements
    const btnConnect = document.getElementById("btnConnect");
    const btnMint = document.getElementById("btnMint");
    const connectedAddrEl = document.getElementById("connectedAddr");
    const walletShort = document.getElementById("walletShort");
    const mintStatus = document.getElementById("mintStatus");
    const networkInfo = document.getElementById("networkInfo");
    const tgUser = document.getElementById("tgUser");
    const receiverBox = document.getElementById("receiverBox");
    const useContractCheckbox = document.getElementById("useContract");

    // show receiver or contract
    if (CONTRACT_ADDRESS) receiverBox.textContent = CONTRACT_ADDRESS;
    else receiverBox.textContent = RECEIVER_ADDRESS;

    // Telegram WebApp display (if opened in Telegram)
    try {
      if (window.Telegram && window.Telegram.WebApp){
        const tg = window.Telegram.WebApp;
        const user = tg.initDataUnsafe && tg.initDataUnsafe.user;
        if (user) tgUser.textContent = (user.first_name || "") + (user.last_name ? " " + user.last_name : "") + " — Telegram";
        else tgUser.textContent = "Telegram WebApp (no user)";
        try { tg.ready(); tg.expand(); } catch(e){}
      }
    } catch(e){}

    // Wallet state
    let provider = null;
    let signer = null;
    let connectedAddress = null;
    let rawProvider = null;

    function short(a){ return a ? a.slice(0,6) + "…" + a.slice(-4) : "—"; }

    async function connectWallet(){
      mintStatus.textContent = "Status: connecting...";
      if (signer) return true;
      // MetaMask
      if (window.ethereum){
        try {
          rawProvider = window.ethereum;
          await rawProvider.request({ method: 'eth_requestAccounts' });
          provider = new ethers.providers.Web3Provider(rawProvider);
          signer = provider.getSigner();
          connectedAddress = await signer.getAddress();
          afterConnect();
          return true;
        } catch(err){
          console.error("MetaMask failed", err);
        }
      }
      // WalletConnect fallback
      try {
        const WalletConnectProvider = window.WalletConnectProvider.default;
        const wcProvider = new WalletConnectProvider({
          rpc: {1: "https://cloudflare-eth.com"},
          chainId: 1,
          qrcode: true
        });
        await wcProvider.enable();
        rawProvider = wcProvider;
        provider = new ethers.providers.Web3Provider(wcProvider);
        signer = provider.getSigner();
        connectedAddress = await signer.getAddress();
        afterConnect();
        return true;
      } catch(err){
        console.error("WalletConnect failed", err);
        mintStatus.textContent = "Status: connection failed";
        return false;
      }
    }

    function afterConnect(){
      connectedAddrEl.textContent = short(connectedAddress);
      walletShort.textContent = "Wallet: " + short(connectedAddress);
      mintStatus.textContent = "Status: connected";
      provider.getNetwork().then(n => networkInfo.textContent = "Network: " + n.name + " (chainId " + n.chainId + ")");
      btnConnect.textContent = "Connected";
      btnConnect.disabled = true;
    }

    async function sendPaymentDirect(){
      if (!signer) { mintStatus.textContent = "Status: wallet not connected"; return; }
      try {
        mintStatus.textContent = "Status: creating tx";
        const value = ethers.utils.parseEther(ETH_AMOUNT);
        const tx = await signer.sendTransaction({ to: RECEIVER_ADDRESS, value });
        mintStatus.innerHTML = `Status: tx sent — <a href="https://etherscan.io/tx/${tx.hash}" target="_blank">${tx.hash}</a>`;
        const receipt = await tx.wait();
        if (receipt && receipt.status === 1){
          mintStatus.innerHTML = `✅ Transaction confirmed — <a href="https://etherscan.io/tx/${tx.hash}" target="_blank">${tx.hash}</a>`;
        } else mintStatus.textContent = "Transaction failed";
      } catch(err){
        console.error(err);
        mintStatus.textContent = "Error: " + (err.message ? err.message.slice(0,200) : "Tx failed");
      }
    }

    async function callContractMint(){
      if (!signer) { mintStatus.textContent = "Status: wallet not connected"; return; }
      if (!CONTRACT_ADDRESS || !CONTRACT_ABI) { mintStatus.textContent = "Contract not configured in config.json"; return; }
      try {
        mintStatus.textContent = "Status: calling contract mint";
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        // If your contract expects payment via msg.value, adjust here. We're calling mintNFT(tokenURI) with value if configured.
        if (TOKEN_URI){
          const tx = await contract.mintNFT(TOKEN_URI, { value: ethers.utils.parseEther(ETH_AMOUNT) });
          mintStatus.innerHTML = `Status: tx sent — <a href="https://etherscan.io/tx/${tx.hash}" target="_blank">${tx.hash}</a>`;
          const receipt = await tx.wait();
          if (receipt && receipt.status === 1){
            mintStatus.innerHTML = `✅ Mint confirmed — <a href="https://etherscan.io/tx/${tx.hash}" target="_blank">${tx.hash}</a>`;
          } else mintStatus.textContent = "Mint tx failed";
        } else {
          // call mintNFT without tokenURI (if your contract mints automatically)
          const tx = await contract.mintNFT({ value: ethers.utils.parseEther(ETH_AMOUNT) });
          mintStatus.innerHTML = `Status: tx sent — <a href="https://etherscan.io/tx/${tx.hash}" target="_blank">${tx.hash}</a>`;
          const receipt = await tx.wait();
          if (receipt && receipt.status === 1){
            mintStatus.innerHTML = `✅ Mint confirmed — <a href="https://etherscan.io/tx/${tx.hash}" target="_blank">${tx.hash}</a>`;
          } else mintStatus.textContent = "Mint tx failed";
        }
      } catch(err){
        console.error(err);
        mintStatus.textContent = "Error: " + (err.message ? err.message.slice(0,200) : "Contract call failed");
      }
    }

    // Button actions
    btnConnect.addEventListener("click", connectWallet);
    btnMint.addEventListener("click", async ()=>{
      btnMint.disabled = true;
      btnMint.textContent = "Processing...";
      await connectWallet();
      // decide: use contract or direct transfer
      if (useContractCheckbox.checked && CONTRACT_ADDRESS){
        await callContractMint();
      } else {
        await sendPaymentDirect();
      }
      btnMint.disabled = false;
      btnMint.textContent = "Mint / Pay $50";
    });

  })();
  </script>
</body>
</html>
"""

# VisionGlasses smart contract
solidity = """// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract VisionGlassesNFT is ERC721URIStorage, Ownable {
    uint256 public tokenCounter;
    uint256 public constant PRICE = 0.02 ether; // ~ $50

    constructor() ERC721("VisionGlassesNFT", "VGNFT") {
        tokenCounter = 0;
    }

    function mintNFT(string memory tokenURI) public payable returns (uint256) {
        require(msg.value >= PRICE, "Not enough ETH sent, price is 0.02 ETH");

        uint256 newItemId = tokenCounter;
        _safeMint(msg.sender, newItemId);
        _setTokenURI(newItemId, tokenURI);

        tokenCounter += 1;
        return newItemId;
    }

    function withdraw() public onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }
}
"""

# config.json template (optional)
config_json = {
    "contractAddress": "",
    "contractAbi": [],
    "tokenURI": ""
}

# metadata template
metadata = {
  "name": "Vision Glasses NFT",
  "description": "Vision Glasses — LuminaVerse collection. BTC, ETH, BNB logos embedded in lens.",
  "image": "ipfs://YOUR_IMAGE_HASH",
  "attributes": [
    {"trait_type":"Edition","value":"Limited"},
    {"trait_type":"Style","value":"Techwear"}
  ]
}

# README
readme = textwrap.dedent("""\
    Vision Glasses — Complete package
    --------------------------------
    Files:
    - index.html        -> Frontend (Telegram + WalletConnect + ethers.js). Edit config.json to enable contract minting.
    - glasses.png       -> Placeholder for your NFT image (replace with your real image).
    - VisionGlassesNFT.sol -> ERC-721 contract (OpenZeppelin) – deploy via Remix or Hardhat.
    - config.json       -> Optional: place contractAddress, contractAbi (array), tokenURI (ipfs://...) to enable contract minting.
    - metadata.json     -> Template for your token metadata (upload to IPFS and set tokenURI).
    
    Quick deploy:
    1. Replace glasses.png with your image file.
    2. (Optional) Upload metadata.json and image to IPFS (Pinata, nft.storage) and set tokenURI in config.json.
    3. Deploy VisionGlassesNFT.sol (Remix + MetaMask). Copy contract address and ABI into config.json.
    4. If you configure contract in config.json, open the site, toggle 'Use contract mint', connect wallet, and click Mint.
    5. Without contract, site will send ETH directly to your RECEIVER address (configured in index.html).
    
    Deploy to Vercel:
    - Create a GitHub repo or drag-and-drop the folder into Vercel deploy (it's a static site).
    """)

# write files
with open(os.path.join(project_dir, "index.html"), "w", encoding="utf-8") as f:
    f.write(index_html)
with open(os.path.join(project_dir, "VisionGlassesNFT.sol"), "w", encoding="utf-8") as f:
    f.write(solidity)
with open(os.path.join(project_dir, "config.json"), "w", encoding="utf-8") as f:
    json.dump(config_json, f, indent=2)
with open(os.path.join(project_dir, "metadata.json"), "w", encoding="utf-8") as f:
    json.dump(metadata, f, indent=2)
with open(os.path.join(project_dir, "README.txt"), "w", encoding="utf-8") as f:
    f.write(readme)

# copy uploaded image if present
uploaded_img = "/mnt/data/44CBA0F3-7AEA-4866-9BB5-4C0765FACC81.png"
if os.path.exists(uploaded_img):
    shutil.copy(uploaded_img, os.path.join(project_dir, "glasses.png"))
else:
    # create a tiny placeholder PNG if image missing
    with open(os.path.join(project_dir, "glasses.png"), "wb") as f:
        f.write(b"")

# create zip
zip_path = "/mnt/data/vision-glasses-complete.zip"
with zipfile.ZipFile(zip_path, 'w') as z:
    for root, _, files in os.walk(project_dir):
        for file in files:
            z.write(os.path.join(root, file), arcname=os.path.join(os.path.basename(project_dir), file))

zip_path
